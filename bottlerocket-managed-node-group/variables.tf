variable "capacity_type" {
  default     = "on-demand"
  description = "Configures the node group's capacity type.  Valid values are 'on-demand' and 'spot'."
  nullable    = false
  type        = string

  validation {
    condition     = contains(["on-demand", "spot"], var.capacity_type)
    error_message = "The capacity type must be either 'on-demand' or 'spot'."
  }
}


variable "eks_cluster" {
  description = <<-EOF
  Attributes of the EKS cluster on which Karpenter is deployed.  The names of the attributes match the names of outputs in the eks-cluster module to allow using the module as the argument to this variable.

  The `cluster_name` attribute the the name of the EKS cluster.  It is required.
  The `cluster_security_group_id` is the ID of the security group generated by EKS when the cluster was created.  It is required.
  The `k8s_version` is the Kubernetes version of the cluster's control plane.  It is required.
  EOF
  nullable    = false
  type = object({
    cluster_name              = string
    cluster_security_group_id = string
    k8s_version               = string
  })

  validation {
    condition     = can(regex("^1\\.((2[4-9])|(3[0-9]))$", var.eks_cluster.k8s_version))
    error_message = "The Kubernetes version must be 1.24 or later."
  }

  validation {
    # The naming constraints are defined at https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateCluster.html#API_CreateCluster_RequestBody
    condition     = can(regex("^[0-9A-Za-z][A-Za-z0-9\\-_]{0,99}$", var.eks_cluster.cluster_name))
    error_message = "The cluster name must adhere to the EKS cluster name restrictions."
  }

  validation {
    condition     = can(regex("^sg-[a-f0-9]+$", var.eks_cluster.cluster_security_group_id))
    error_message = "The cluster_security_group_id attribute is not a syntactically valid security group ID."
  }
}



variable "instance_types" {
  description = <<-EOF
  The instance types used for the nodes in the group.  Multiple types can be specified to minimze the impact of
  insufficient instance capacity in an availability zone.
  https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups.html
  https://docs.aws.amazon.com/eks/latest/userguide/security-groups-for-pods.html#supported-instance-types
  https://docs.aws.amazon.com/eks/latest/userguide/choosing-instance-type.html
  EOF
  nullable    = false
  type        = set(string)
  validation {
    condition     = length(var.instance_types) > 0
    error_message = "A least one instance type must be provided."
  }
}

variable "bottlerocket_version" {
  default     = "latest"
  description = <<-EOF
  The version of Bottlerocket to deploy in the node group.  The value must be either the string 'latest' to always deploy the latest version available
  for the EKS cluster version or the semantic version string of a Bottlerocket release.  Available versions can be found at
  https://github.com/bottlerocket-os/bottlerocket/release or in public SSM parameters as described at
  https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami-bottlerocket.html
  EOF
  nullable    = false
  type        = string
  validation {
    condition     = can(regex("^(latest)|(\\d+\\.\\d+\\.\\d+)$", var.bottlerocket_version))
    error_message = "The value of the 'bottlerocket_version' variable must be either the stirng 'latest' or a semantic version string."
  }
}

variable "container_registry_mirrors" {
  default     = []
  description = <<-EOF
  A list of objects for configuring containerd registry mirrors.

  The 'registry' attribute is the hostname of the upstream registry.
  The 'endpoint' attrbute is the URL of the mirror.

  https://github.com/bottlerocket-os/bottlerocket#container-image-registry-settings
  https://github.com/containerd/containerd/blob/main/docs/hosts.md#setup-a-local-mirror-for-docker
  EOF
  nullable    = false
  type = list(object(
    {
      endpoint = string
      registry = string
    }
  ))

  validation {
    condition     = alltrue([for mirror in var.container_registry_mirrors : can(regex("^([a-z0-9\\-]+\\.)*[a-z0-9\\-]+$", mirror.registry))])
    error_message = "The registry values must be syntactically valid hostnames."
  }

  validation {
    condition     = alltrue([for mirror in var.container_registry_mirrors : can(regex("^https://([a-z0-9\\-]+\\.)*[a-z0-9\\-]+$", mirror.endpoint))])
    error_message = "The endpoint values must be syntactically valid HTTPS URLs without any path components."
  }
}

variable "labels" {
  default     = {}
  description = "Key-value map of Kubernetes labels to assign to every node."
  type        = map(string)
}

variable "name_prefix" {
  description = "The value to use as the prefix of the name of the AWS resources created for the managed node group."
  type        = string
  validation {
    condition     = length(trimspace(var.name_prefix)) > 0
    error_message = "The name_prefix cannot be empty."
  }
  validation {
    condition     = !endswith(var.name_prefix, "-")
    error_message = "The name_prefix cannot end with a '-' character."
  }
}

variable "iam_role_arn" {
  description = "The ARN of the IAM role the nodes will assume."
  nullable    = false
  type        = string
  validation {
    condition     = length(trimspace(var.iam_role_arn)) > 0
    error_message = "The iam_role_arn cannot be empty."
  }
}

variable "security_group_ids" {
  default     = []
  description = "An optional list of the unique identifiers of additional security groups to attach to the nodes' ENIs."
  nullable    = false
  type        = list(string)
}

variable "size" {
  description = "The minimum, maximum, and desired size of the autoscaling group that manages the nodes."
  default = {
    desired = 1
    max     = 1
    min     = 1
  }
  nullable = false
  type = object(
    {
      desired = number
      max     = number
      min     = number
    }
  )
  validation {
    condition     = alltrue([for v in values(var.size) : 0 <= v]) && var.size.min <= var.size.max && var.size.desired <= var.size.max && var.size.min <= var.size.desired
    error_message = "All size values must be greater than or equal to zero. The min value must be less than or equal to the max value. The desired value must be less than or equal to the max value and greater than or equal to the min value."
  }
}

variable "subnet_ids" {
  description = "The unique identifiers of the subnets where the nodes will launch."
  nullable    = false
  type        = list(string)
  validation {
    condition     = length(var.subnet_ids) > 0
    error_message = "At least one subnet must be specified."
  }
}

variable "tags" {
  default     = {}
  description = "An optional map of AWS tags to attach to every resource created by the module."
  nullable    = false
  type        = map(string)
}

variable "taints" {
  default     = []
  description = <<-EOF
  The Kubernetes taints to be applied to the nodes in the node group. Maximum of 50 taints per node group.
  For more details, see https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html.
  EOF
  type = list(object({
    key    = string
    value  = string
    effect = string
  }))

  validation {
    condition     = length(var.taints) <= 50
    error_message = "Cannot specify more than 50 node taints."
  }

  validation {
    condition     = alltrue([for t in var.taints : contains(["NO_SCHEDULE", "PREFER_NO_SCHEDULE", "NO_EXECUTE"], t.effect)])
    error_message = "Taint effects must be one of NO_SCHEDULE, PREFER_NO_SCHEDULE, or NO_EXECUTE."
  }
}

variable "volume_iops" {
  default     = 3000
  description = "The IOPS of the root volume of every node in the node group."
  nullable    = false
  type        = number
  validation {
    condition     = 3000 <= var.volume_iops && var.volume_iops <= 16000
    error_message = "Invalid volume IOPS.  See https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html#gp3-ebs-volume-type for valid values."
  }
}

variable "volume_size" {
  default     = 1024
  description = "The size, in gigabytes, of the root volume of every node in the node group."
  nullable    = false
  type        = number
  validation {
    condition     = 1 <= var.volume_size && var.volume_size <= 16384
    error_message = "Invalid volume size.  See https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html#solid-state-drives for valid values."

  }
}

variable "volume_throughput" {
  default     = 125
  description = "The throughput of the root volume of every node in the node group."
  nullable    = false
  type        = number
  validation {
    condition     = 125 <= var.volume_throughput && var.volume_throughput <= 1000
    error_message = "Invalid volume throughput.  See https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html#gp3-ebs-volume-type for valid values."

  }
}
