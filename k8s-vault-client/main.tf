terraform {
  required_providers {
    helm = {
      source  = "hashicorp/helm"
      version = ">= 2.10"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = ">= 2.23"
    }
    kubectl = {
      source  = "alekc/kubectl"
      version = ">= 2.0"
    }
    vault = {
      source  = "hashicorp/vault"
      version = ">= 3.20"
    }
  }
  required_version = ">= 1.5"
}

locals {
  labels = merge(
    var.labels,
    {
      "app.kubernetes.io/managed-by" = "terraform"
    }
  )

  vault_metadata = merge(
    var.auth_backend.metadata,
    {
      managed_with = "terraform"
    }
  )

  # Define a local for the CSI providers directory to ensure it is the same for both Helm releases.
  # The directory was originally under /etc but was recently moved to /var to conform to Linux directory standards.
  # The driver supports reading from both the /etc-and /var directories but there is no reason not to switch to /var.
  # See https://github.com/kubernetes-sigs/secrets-store-csi-driver/pull/851 for more detail.
  csi_providers_directory = "/var/run/secrets-store-csi-providers"
}


###################################################
# Install the Custom Resource Definitions
###################################################
locals {
  crd_directory = "${path.module}/files/crds/${var.secrets_store_csi_driver_chart_version}"
}

# Use kubectl_manifest instead of kubernetes_manifest because kubernetes_manifest is buggy.
resource "kubectl_manifest" "crd" {
  for_each = fileset(local.crd_directory, "*")

  # Set this true or else TF will fail when updating a CRD that was originally created by Helm.
  force_conflicts = true
  # Server side apply must be used or else some CRDs will error out with "metadata.annotations: Too long: must have at most 262144 bytes"
  server_side_apply = true
  wait              = true
  yaml_body         = file("${local.crd_directory}/${each.key}")
}

# https://secrets-store-csi-driver.sigs.k8s.io/
# https://github.com/kubernetes-sigs/secrets-store-csi-driver/tree/main/charts/secrets-store-csi-driver
resource "helm_release" "secrets_store_csi" {
  atomic           = true
  chart            = "secrets-store-csi-driver"
  cleanup_on_fail  = true
  create_namespace = false
  description      = "Secrets Store CSI Driver"
  # The only hooks in the chart (as of 1.2.x) are for managing the CRDs.  Disalbe the hooks to ensure that TF is the only thing managing the CRDs,
  disable_webhooks = true
  max_history      = 5
  name             = "secrets-store-csi-driver"
  namespace        = "kube-system"
  recreate_pods    = true
  repository       = "https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts"
  skip_crds        = true
  version          = var.secrets_store_csi_driver_chart_version

  values = [
    yamlencode(
      {
        enableSecretRotation = true
        commonLabels         = local.labels
        linux = {
          affinity = {
            # Prevent scheduling on Fargate nodes
            nodeAffinity = {
              requiredDuringSchedulingIgnoredDuringExecution = {
                nodeSelectorTerms = [
                  {
                    matchExpressions = [
                      {
                        key      = "eks.amazonaws.com/compute-type"
                        operator = "NotIn"
                        values   = ["fargate"]
                      }
                    ]
                  }
                ]
              }
            }
          }
          priorityClassName = "system-node-critical"
          # Explicitly set the providers directory even though the local value is the same as the chart default.
          providersDir = local.csi_providers_directory
        }
        syncSecret = {
          enabled = true
        }
        crds = {
          enabled = false
        }
      }
    )
  ]

  depends_on = [
    kubectl_manifest.crd,
  ]
}

resource "vault_auth_backend" "kubernetes" {
  description = <<-EOF
  Authenticates Kubernetes service tokens generated by the ${var.kubernetes_cluster.cluster_name} EKS cluster.

  ----- Metadata -----
  %{for k, v in local.vault_metadata~}${k}: ${v}
  %{endfor~}--------------------
  EOF
  path        = var.auth_backend.path
  type        = "kubernetes"
  tune {
    # Ensure the role is logged in plain text for easier tracking debugging.
    # https://support.hashicorp.com/hc/en-us/articles/360000995548-Audit-and-Operational-Log-Details
    audit_non_hmac_request_keys = ["role"]
    listing_visibility          = "hidden"
  }
}

resource "vault_kubernetes_auth_backend_config" "kubernetes" {
  backend            = vault_auth_backend.kubernetes.path
  kubernetes_host    = var.kubernetes_cluster.cluster_endpoint
  kubernetes_ca_cert = var.kubernetes_cluster.certificate_authority_pem
  # Ensure issuer validation is set to false as per https://developer.hashicorp.com/vault/docs/auth/kubernetes#discovering-the-service-account-issuer
  disable_iss_validation = true
  # Set the token to null to ensure previous value is removed.
  token_reviewer_jwt = null
}

resource "helm_release" "vault" {
  atomic           = true
  chart            = "vault"
  cleanup_on_fail  = true
  create_namespace = false
  description      = "The Vault CSI driver and the Vault agent injector"
  max_history      = 5
  name             = "vault"
  namespace        = var.namespace
  recreate_pods    = true
  repository       = "https://helm.releases.hashicorp.com"
  # When modifying the chart version, be sure to check for
  # any image tag overrides in the values.
  version = var.vault_chart_version

  # The chart doesn't set any default resource request or limit values.
  # It does, however, provide some values in the comments.  Those
  # values are used here.
  values = [
    yamlencode(
      {
        csi = {
          agent = {
            image = {
              repository = "${var.image_registry}/hashicorp/vault"
            }
          }
          daemonSet = {
            extraLabels = local.labels
            # Set this to match the default value of the CSI driver chart's linux.providersDir value.
            # The default in this chart is the deprecated /etc/kubernetes/secrets-store-csi-providers path.

            providersDir = local.csi_providers_directory
          }
          enabled = true
          # Set a default auth mount so that it doesn't have to be configured in the
          # https://developer.hashicorp.com/vault/docs/platform/k8s/csi/configurations#command-line-arguments
          # The value passed to the vault-mount argument must the name of the mount.  NOT the path of the mount.
          # In other words, do not include the 'auth/' prefix.  The docs don't mention it, nor does is there any
          # validation for it.  In the code, however, the prefix is added when the provider builds the login URL.
          # https://github.com/hashicorp/vault-csi-provider/blob/main/internal/provider/provider.go
          extraArgs = [
            "-vault-mount=${vault_auth_backend.kubernetes.path}"
          ]
          image = {
            repository = "${var.image_registry}/hashicorp/vault-csi-provider"
          }
          pod = {
            extraLabels = local.labels
          }
          priorityClassName = "system-node-critical"
          resources         = var.vault_csi_provider_configuration.resources
          serviceAccount = {
            extraLabels = local.labels
          }
        }
        global = {
          externalVaultAddr = var.vault_server_address
        }
        injector = {
          agentImage = merge(
            {
              repository = "${var.image_registry}/hashicorp/vault"
            },
            # Override the chart's tag if one was supplied by the caller.
            var.agent_default_configuration.vault_version == null ? {} : { tag = var.agent_default_configuration.vault_version }
          )
          agentDefaults = {
            cpuLimit         = var.agent_default_configuration.resources.limits.cpu
            cpuRequest       = var.agent_default_configuration.resources.requests.cpu
            ephemeralLimit   = var.agent_default_configuration.resources.limits.ephemeral_storage
            ephemeralRequest = var.agent_default_configuration.resources.requests.ephemeral_storage
            memLimit         = var.agent_default_configuration.resources.limits.memory
            memRequest       = var.agent_default_configuration.resources.requests.memory
            template         = var.agent_default_configuration.template_type
            templateConfig = {
              exitOnRetryFailure         = var.agent_default_configuration.template_config.exit_on_retry_failure
              staticSecretRenderInterval = var.agent_default_configuration.template_config.static_secret_render_interval
            }
          }
          authPath    = "auth/${vault_auth_backend.kubernetes.path}"
          enabled     = true
          extraLabels = local.labels
          image = {
            repository = "${var.image_registry}/hashicorp/vault-k8s"
          }
          logFormat = "json"
          metrics = {
            enabled = true
          }
          nodeSelector = var.agent_injector_configuration.node_selector
          podDisruptionBudget = {
            maxUnavailable = "50%"
          }
          priorityClassName = "system-cluster-critical"
          replicas          = var.agent_injector_configuration.replicas
          resources         = var.agent_injector_configuration.resources
          revokeOnShutdown  = true
        }

        server = {
          enabled = false
        }
      }
    )
  ]

  depends_on = [
    helm_release.secrets_store_csi,
    vault_kubernetes_auth_backend_config.kubernetes
  ]
}
